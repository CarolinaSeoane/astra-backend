import requests
from datetime import datetime
from bson import ObjectId
from app.models.notification import Notification
from app.models.team import Team


def notify_story_update(story, updated_fields, team_id):
    """
    Enviar notificaciones sobre los cambios realizados a la historia, excluyendo cambios en `team`, `_id`, y `subscribers`.
    Si se modifica el campo `comments`, enviará el contenido del comentario.
    """
    print(f"Notificando actualización de historia. Old Story: {story}, Updated Fields: {updated_fields}, Team ID: {team_id}")

    creator_id_str = extract_id_string(story.get('creator', {}).get('_id', ''))
    subscribers = story.get('subscribers', [])
    assigned_to = story.get('assigned_to', {})
    assigned_to_id_str = extract_id_string(assigned_to.get('_id', ''))
    
    notifications = prepare_notifications(story, updated_fields, assigned_to_id_str)

    # Enviar notificaciones
    send_notifications_to_users(notifications, creator_id_str, assigned_to_id_str, subscribers, story, team_id)


def extract_id_string(id_field):
    """ Extraer y validar el ObjectId del campo, si es válido. """
    if isinstance(id_field, ObjectId):
        return str(id_field)
    if isinstance(id_field, dict) and '$oid' in id_field:
        return id_field['$oid']
    return ''


def prepare_notifications(story, updated_fields, assigned_to_id_str):
    """ Prepara las notificaciones basadas en los campos actualizados. """
    notifications = []

    if 'title' in updated_fields:
        notifications.append((assigned_to_id_str, f"El título de la historia se ha cambiado a '{updated_fields['title']}'."))

    if 'acceptance_criteria' in updated_fields:
        notifications.append((assigned_to_id_str, f"Se han actualizado los criterios de aceptación de la historia '{story.get('title', 'No Title')}'."))

    if 'assigned_to' in updated_fields:
        new_assigned_user_str = extract_id_string(updated_fields['assigned_to'].get('_id', ''))
        notifications.append((new_assigned_user_str, f"Se ha cambiado el usuario asignado a la historia '{story.get('title', 'No Title')}'."))

    if 'epic' in updated_fields:
        notifications.append((assigned_to_id_str, f"Se ha actualizado la épica de la historia '{story.get('title', 'No Title')}'."))

    if 'sprint' in updated_fields:
        notifications.append((assigned_to_id_str, f"Se ha cambiado el sprint de la historia '{story.get('title', 'No Title')}'."))

    if 'estimation' in updated_fields:
        notifications.append((assigned_to_id_str, f"Se ha cambiado la estimación de la historia '{story.get('title', 'No Title')}' a {updated_fields['estimation']} puntos."))

    if 'tags' in updated_fields:
        notifications.append((assigned_to_id_str, f"Se han actualizado las etiquetas de la historia '{story.get('title', 'No Title')}'."))

    if 'priority' in updated_fields:
        notifications.append((assigned_to_id_str, f"Se ha cambiado la prioridad de la historia '{story.get('title', 'No Title')}' a {updated_fields['priority']}."))

    if 'tasks' in updated_fields:
        notifications.append((assigned_to_id_str, f"Se han actualizado las tareas de la historia '{story.get('title', 'No Title')}'."))

    if 'estimation_method' in updated_fields:
        notifications.append((assigned_to_id_str, f"Se ha cambiado el método de estimación a '{updated_fields['estimation_method']}' para la historia '{story.get('title', 'No Title')}'."))

    return notifications


def send_notifications_to_users(notifications, creator_id_str, assigned_to_id_str, subscribers, story, team_id):
    """ Enviar las notificaciones preparadas a los usuarios correspondientes. """

    for user_id_str, message in notifications:
        if validate_object_id(user_id_str):
            create_and_send_notification(user_id_str, message, story, creator_id_str, assigned_to_id_str, team_id)

    if creator_id_str and len(creator_id_str) == 24:
        for user_id_str, message in notifications:
            if user_id_str != creator_id_str:
                create_and_send_notification(creator_id_str, message, story, creator_id_str, assigned_to_id_str, team_id)

    send_notifications_to_subscribers(subscribers, notifications, story, creator_id_str, assigned_to_id_str, team_id)

    # Notificar al Product Owner si corresponde
    po_id = get_product_owner_id(team_id)
    if po_id:
        for _, message in notifications:
            create_and_send_notification(po_id, message, story, creator_id_str, assigned_to_id_str, team_id)


def validate_object_id(id_str):
    """ Validar si un string puede ser un ObjectId válido. """
    return ObjectId.is_valid(id_str)


def create_and_send_notification(user_id_str, message, story, creator_id_str, assigned_to_id_str, team_id):
    """ Crear y enviar una notificación a un usuario específico. """
    try:
        Notification.create_notification({
            'user_id': ObjectId(user_id_str),
            'message': message,
            'story_id': story.get('_id', 'No ID'),
            'creator': ObjectId(creator_id_str),
            'assigned_to': ObjectId(assigned_to_id_str) if assigned_to_id_str == user_id_str else None,
            'team_id': ObjectId(team_id),
            'created_at': datetime.now().isoformat(),
            'viewed_by': []
        })
        print(f"Notificación enviada a {user_id_str}: {message}")
    except Exception as e:
        print(f"Error al crear notificación para {user_id_str}: {e}")


def send_notifications_to_subscribers(subscribers, notifications, story, creator_id_str, assigned_to_id_str, team_id):
    """ Enviar notificaciones a los suscriptores de la historia. """
    for subscriber in subscribers:
        subscriber_id_str = extract_id_string(subscriber.get('_id', {}))
        if validate_object_id(subscriber_id_str):
            for _, message in notifications:
                create_and_send_notification(subscriber_id_str, message, story, creator_id_str, assigned_to_id_str, team_id)


def get_product_owner_id(team_id):
    """ Obtener el ID del Product Owner basado en el equipo. """
    team = Team.get_team(ObjectId(team_id))
    if team:
        for member in team.get('members', []):
            if member.get('role') == 'Product Owner':
                po_id = extract_id_string(member.get('_id'))
                return po_id
    return None


def is_product_owner(user_id, team_id):
    """ Verificar si un usuario es Product Owner en un equipo. """
    endpoint_url = f"http://127.0.0.1:5000/teams/product_owner/role_check/{user_id}"
    try:
        response = requests.get(endpoint_url, params={'team_id': team_id})
        if response.status_code == 200:
            result = response.json()
            return result.get('data')
        print(f"Error al verificar estado de Product Owner: {response.status_code}")
    except requests.exceptions.RequestException as e:
        print(f"Error al conectar con el endpoint de Product Owner: {e}")
    return False
